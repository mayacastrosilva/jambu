/ *
 Direitos autorais (C) Federico Zivolo 2017
 Distribuído sob a licença MIT (os termos da licença estão em http://opensource.org/licenses/MIT).
 * / (function (e, t) {'objeto' == tipo de exportação && 'indefinido'! = tipo de módulo? module.exports = t (): 'função' == tipoof define && define.amd? define (t): e. Popper = t ()}) (isso, function () {'use strict'; função e (e) {return e && '[objeto Function]' === {}. ToString.call (e)} função t (e , t) {if (1! == e.nodeType) return []; var o = getComputedStyle (e, nulo); retorno t? o [t]: o} função o (e) {return'HTML '== = e.nodeName? e: e.parentNode || e.host} função n (e) {if (! e) retornar document.body; switch (e.nodeName) {case'HTML ': case'BODY': retornar e.ownerDocument.body; case '# document': return e.body;} var i = t (e), r = i.overflow, p = i.overflowX, s = i.overflowY; retorno / (auto | rolagem ) teste (r + s + p) e: n (o (e))} função r (e) {var o = e & e.offsetParent, i = o && o.nodeName; return i && 'BODY'! == i && 'HTML '! == i? -1! == [' TD ',' TABLE ']. IndexOf (o.nodeName) &&' estático '=== t (o,' posição ')? R (o): o : e? e.ownerDocument.documentElement: document.documentElement} função p (e) {var t = e.nodeName; return'BODY '! == t && (' HTML '=== t || r (e.firstElementChild) === e)} função s (e) {return null === e.parentNode? e: s (e.parentNode)} função d (e, t) {if (! e ||! e.nodeType || ! t || t.nodeType) return document.documentElement; var o = e.compareDocumentPosition (t) & Node.DOCUMENT_POSITION_FOLLOWING, i = o? e: t, n = o? t: e, a = document.createRange () ; a.setStart (i, 0), a.setEnd (n, 0); var l = a.commonAncestorContainer; if (e! == l && t! == l || i.contains (n)) return p (l l: r (l); var f = s (e); retorno f.host?d(f.host,t):d(e,s(t).host )}function a (e) {var t = 1 <arguments.length && void 0! == argumentos [1]? argumentos [1]: 'top', o = 'topo' === t? 'scrollTop ':' scrollLeft ', i = e.nodeName; if (' BODY '=== i ||' HTML '=== i) {var n = e.ownerDocument.documentElement, r = e.ownerDocument.scrollingElement | | n; return r [o]} return e [o]} função l (e, t) {var o = 2 <argumentos.length && void 0! == argumentos [2] && argumentos [2], i = a (t, 'top'), n = a (t, 'esquerda'), r = o? -1: 1; retorno e.top + = i * r, e.bottom + = i * r, e.left + = n * r, e.right + = n * r, e} função f (e, t) {var o = 'x' === t 'esquerda': 'superior', i = 'esquerda' = = o 'direita': 'Bottom'; retorna parseFloat (e ['border' + o + 'Width'], 10) + parseFloat (e ['border' + i + 'Width'], 10)} função m (e, t, o, i) {retornar J (t ['deslocamento' + e], t ['rolar' + e], o ['cliente' + e], o ['deslocamento' + e], o ['rolar' + e], ou seja ()? o ['deslocamento' + e] + i ['margem' + ('Altura' === e? 'Topo': 'Esquerda ')] + i [' margin '+ (' Height '=== e?' Bottom ':' Right ')]: 0)} função h () {var e = document.body, t = document.documentElement , o = ie () && getComputedStyle (t); return {altura: m ('Altura', e, t, o), largura: m ('Largura', e, t, o)}} função c (e) { retorna se ({}, e, {direita: e.left + e.width, bottom: e.top + e.height})} função g (e) {var o = {}; se (ie ()) tentar {o = e.getBoundingClientRect (); var i = a (e, 'top'), n = a (e, 'esquerda'); o.top + = i, o.left + = n, o.bottom + = i, o.right + = n} catch (e) {} mais o = e.getBoundingClientRect (); var r = {esquerda: o.left, topo: o.top, largura: o.right-o.left, altura: o .bottom-o.top}, p = 'HTML' === e.nodeName? h (): {}, s = p.width || e.clientWidth || r.right-r.left, d = p .height || e.clientHeight || r.bottom-r.top, l = e.offsetWidth-s, m = e.offsetHeight-d; if (l || m) {var g = t (e); l - = f (g, 'x'), m = f (g, 'y'), r.width- = l, r.height- = m} return c (r)} função u (e, o) {var i = ie (), r = 'HTML' === o.nodeName, p = g (e), s = g (o ), d = n (e), a = t (o), f = parseFloat (a.borderTopWidth, 10), m = parseFloat (a.borderLeftWidth, 10), h = c ({superior: p.top-s .top-f, esquerda: p.left-s.left-m, largura: p.width, height: p.height}); if (h.marginTop = 0, h.marginLeft = 0,! i && r) {var u = parseFloat (a.marginTop, 10), b = parseFloat (a.marginLeft, 10); h.top- = fu, h.bottom- = fu, h.left- = mb, h.right- = mb, h.marginTop = u, h.marginLeft = b} retorno (i? o.contains (d): o === d && 'BODY'! == d.nodeName) && (h = l (h, o)), h} funç˜ao b (e) {var t = e.ownerDocument.documentElement, o = u (e, t), i = J (t.clientWidth, window.innerWidth || 0), n = J (t.clientHeight, window.innerHeight || 0), r = a (t), p = a (t, 'esquerda'), s = {topo: ro.top + o.marginTop, esquerda: po.left + o.marginLeft, largura : i, altura: n}; retorno c (s)} função w (e) {var i = e.nodeName; retorno'BODY '=== i ||' HTML '=== i?! 1: 'fixo' === t (e 'posição') || w (o (e))} função y (e, t, i, r) {var p = {superior: 0, left: 0}, s = d (e, t); if ('porta de visualização' === r) p = b (s); mais {var a; 'scrollParent' === r? (A = n (o (t)), 'BODY' === a.nodeName && (a = e.ownerDocument.documentElement)): 'janela' === r? a = e.ownerDocument.documentElement: a = r; var l = u (a, s); if ('HTML' === a.nodeName &&! w (s)) {var f = h (), m = f.height, c = f.width; p.top + = l. top-l.marginTop, p.bottom = m + l.top, p.left + = l.left-l.marginLeft, p.right = c + l.left} else p = l} return p.left + = i, p.top + = i, p.right- = i, p.bottom- = i, p} função E (e) {var t = e.width, o = e.height; retorno t * o} função v (e , t, o, i, n) {var r = 5 <argumentos.length && void 0! == argumentos [5]? argumentos [5]: 0; if (-1 === e.indexOf ('auto')) return e; var p = y (o, i, r, n), s = {topo: {largura: p.width, altura: t.top-p.top}, direita: {largura: p.right-t .right, height: p.height},bottom: {largura: p.width, altura: p.bottom-t.bottom}, esquerda: {largura: t.left-p.left, altura: p.height}}, d = Object.keys (s). map (função (e) {return se ({chave: e}, s [e], {área: E (s [e])})}). sort (função (e, t) {return t.area- e.area}), a = d.filter (função (e) {var t = e.width, i = e.height; retorno t> = o.clientWidth && i> = o.clientHeight}), l = 0 <a .comprimento? a [0] .chave: d [0] .key, f = e.split ('-') [1]; retorno l + (f? '-' + f: '')} função O (e , t, o) {var i = d (t, o); retorno u (o, i)} função L (e) {var = getComputedStyle (e), o = parseFloat (t.marginTop) + parseFloat (t .marginBottom), i = parseFloat (t.marginLeft) + parseFloat (t.marginRight), n = {largura: e.offsetWidth + i, altura: e.offsetHeight + o}; retorno n} função x (e) {var t = {esquerda: 'direita', direita: 'esquerda', inferior: 'superior', superior: 'inferior'}; retorno e.replace (/ esquerda | direita | inferior | topo / g, função (e) {retorno t [e]})} função S (e, t, o) {o = o.split ('-') [0]; var i = L (e), n = {largura: i.width, altura: i.height}, r = -1! == ['right', 'left'] .indexOf (o), p = r 'topo': 'esquerda', s = r 'esquerda': 'topo', d = r 'altura': 'largura', a = r 'largura': 'altura'; retorno n [p] = t [p] + t [d] / 2-i [d] / 2, n [s] = o === s? t [s] -i [a]: t [x (s)], n} função T (e, t) {retorno Array.prototype.find? e.find (t): e.filter (t) [0]} função D (e, t, o ) {if (Array.prototype.findIndex) retorna e.findIndex (função (e) {return e [t] === o}); var i = T (e, função (e) {return e [t] = == o}); return e.indexOf (i)} função C (t, o, i) {var n = void 0 === i? t: t.slice (0, D (t, 'nome', i)); retorna n.forEach (function (t) {t ['function'] && console.warn ('`modifier.function` é preterido, use` modifier.fn`!'); var i = t ['function '|||||||||offsets.reference = c (o.offsets.reference), o = i (o, t))}), o} função N () {if (! this.state.isDestroyed) {var e = {instance: this, styles: {}, arrowStyles: {}, atributos: {}, invertidos:! 1, offsets: {}}; e.offsets.reference = O (this.state, this.popper, this.reference), e.placement = v (this.options.placement, e.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding), e.originalPlacement = e. posicionamento, e.offsets.popper = S (this.popper, e.offsets.reference, e.placement), e.offsets.popper.position = 'absoluto', e = C (this.modifiers, e), this. state.isCreated? this.options.onUpdate (e) :( this.state.isCreated =! 0, this.options.onCreate (e))}} função k (e, t) {return e.some (função (e ) {var o = e.name, i = e.enabled; return i && o === t})} function W (e) {para (var t = [! 1, 'ms', 'Webkit', 'Moz' , 'O'], o = e.charAt (0).toUpperCase () + e.slice (1), n ​​= 0; n <t.length-1; n ++) {var i = t [n], r = i? '' + i + o: e; if (' undefined '! = tipo de document.body.style [r]) return r} retorno null} function P () {retornar this.state.isDestroyed =! 0, k (this.modifiers,' applyStyle ') && (this.popper .removeAttribute ('x-placement'), this.popper.style.left = '', this.popper.style.position = '', this.popper.style.top = '', this.popper.style [W ('transform')] = ''), this.disableEventListeners (), this.options.removeOnDestroy && this.popper.parentNode.removeChild (this.popper), esta} função B (e) {var t = e.ownerDocument; return t? t.defaultView: window} função H (e, t, o, i) {var r = 'CORPO' === e.nodeName, p = r? e.ownerDocument.defaultView: e; p.addEventListener (t , o, {passivo:! 0}), r || H (n (p.parentNode), t, o, i), i.push (p)} função A (e, t, o, i) {o .updateBound = i, B (e).addEventListener ('resize', o.updateBound, {passivo:! 0}); var r = n (e); retorna H (r, 'rolar', o.updateBound, o.scrollParents), o.scrollElement = r, o.eventsEnabled =! 0, o} função I () {this.state.eventsEnabled || (this.state = A (this.referência, this.options, this.state, this.scheduleUpdate))} função M (e , t) {return B (e) .removeEventListener ('redimensionar', t.updateBound), t.scrollParents.forEach (função (e) {e.removeEventListener ('scroll', t.updateBound)}), t.updateBound = null, t.scrollParents = [], t.scrollElement = null, t.eventsEnabled =! 1, t} função R () {this.state.eventsEnabled && (cancelAnimationFrame (this.scheduleUpdate), this.state = M (este .reference, this.state))} função U (e) {return ''! == e &&! isNaN (parseFloat (e)) && isFinite (e)} função Y (e, t) {Object.keys (t). forEach (function (o) {var i = ''; - 1! == ['largura', 'height ',' top ',' right ',' bottom ',' left ']. indexOf (o) && U (t [o]) && (i =' px '), e.style [o] = t [o ] + i})} função j (e, t) {Object.keys (t) .forCada (função (o) {var i = t [o] ;! 1 === i? e.removeAttribute (o): e.setAttribute (o, t [o])})} função F (e, t, o) {var i = T (e, função (e) {var o = e.nome; retorno o === t} ), n = !! i && e.some (função (e) {return e.name === o && e.enabled && e.order <i.order}); if (! n) {var r = '`' + t + '` '; console.warn (modificador' '' + o + '`' + 'é requerido pelo modificador' + r + 'para funcionar, certifique-se de incluí-lo antes de' + r + '!')} return n} função K ( e) {return'end '=== e?' start ':' start '=== e?' end ': e} função q (e) {var t = 1 <argumentos.length && void 0! == argumentos [ 1] && argumentos [1], o = ae.indexOf (e), i = ae.slice (o + 1).concat (ae.slice (0, o)); retorno t? i.reverse (): i} função V (e, t, o, i) {var n = e.match (/ ((?: \ - | \ +)? \ d * \.? \ d *) (. *) /), r = + n [1], p = n [2]; if (! r) return e; if (0 === p.indexOf ('%')) {var s; switch (p) {caso '% p': s = o; quebra; caso '%': caso '% r': padrão: s = i;} var d = c (s); retorno d [t] / 100 * r} se ('vh' === p || 'vw' === p) {var a; return a = 'vh' === p? J (document.documentElement.clientHeight, window.innerHeight || 0): J (document.documentElement.clientWidth, window.innerWidth || 0), um / 100 * r} retorno r} função z (e, t, o, i) {var n = [0,0], r = -1! == ['direita', 'esquerda']. indexOf (i), p = e.split (/ (\ + | \ -) ​​/) .map (função (e) {return e.trim ()}), s = p.indexOf (T (p, função (e) {return-1! == e.search (/, | \ s /)} )); p [s] && - 1 === p [s] .indexOf (',') && console.warn ('Os deslocamentos separados por espaço (s) em branco estão obsoletos, use uma vírgula (,) em vez disso.') ;var d = / \ s *, \ s * | \ s + /, a = -1 === s? [p]: [p.slice (0, s) .concat ([p [s] .split (d ) [0]], [p [s] .split (d) [1]]. Concat (p.slice (s + 1))]; retorne a = a.map (função (e, i) {var n = (1 === i?! r: r)? 'altura': 'largura', p =! 1; return e.reduce (função (e, t) {return '' === e [e. length-1] && - 1! == ['+', '-']. indexOf (t)? (e [e.length-1] = t, p = 0, e): p? e.length-1] + = t, p =! 1, e): e.concat (t)}, []). map (função (e) {retorno V (e, n, t, o)}) }), a.forEach (função (e, t) {e.forEach (função (o, i) {U (o) && (n [t] + = o * ('-' === e [i] 1]? - 1: 1))})}), n} funç˜ao G (e, t) {var, i = t.offset, n = e.placement, r = e.offsets, p = r.popper , s = r.reference, d = n.split ('-') [0]; retorno o = U (+ i)? [+ i, 0]: z (i, p, s, d), 'esquerda '=== d? (p.top + = o [0], p.left- = o [1]):' right '=== d? (p.top + = o [0], p.left + = o [1]): 'topo' === d? (P.left + = o [0], p.top- = o [1]): 'inferior' === d && (p.left + = o [0] p.top + = o [1]), e.popper = p, e} para (var _ = Math.min, X = Math.floor, J = Math.max, Q = 'indefinido'! = tipo de janela && 'indefinido'! = tipo de documento, Z = ['Edge', 'Trident', 'Firefox'], $ = 0, ee = 0; ee <Z.length; ee + = 1) if (Q && 0 <= navigator.userAgent.indexOf (Z [ee])) {$ = 1; break} var i, te = Q e& window.Promise, oe = te? função (e) {var t =! 1; função de retorno () {t || (t =! 0, window.Promise.resolve (). then (function () {t =! 1, e ()})}}} function (e) {var t =! 1; função return () {t || (t = ! 0, setTimeout (function () {t =! 1, e ()}, $))}}, ie = function () {retorno void 0 == i && (i = -1! == navigator.appVersion.indexOf ('MSIE 10')), i}, ne = função (e, t) {if (! (E instanceof t)) lança novo TypeError ('Não é possível chamar uma classe como uma função')}, re = function () {função e (e, t) {para (var o, n = 0; n <t.length; n ++) o = t [n], o.enumerável = o.enumerável ||! 1, o.configurable =! 0, 'value'in o && (o.writable =! 0), Object.defineProperty (e, o.key, o)} função de retorno (t, o, i) {retorno o && e (t.prototipo, o), i && e (t, i), t}} (), pe = função (e, t, o) {retorno t em e? Object.defineProperty (e, t, {valor: o, enumerável:! 0, configurável:! 0, gravável: ! 0}): e [t] = o, e}, se = Object.assign || function (e) {para (var t, o = 1; o <argumentos.length; o ++) para (var i em t = argumentos [o], t) Object.prototype.hasOwnProperty.call (t, i) && (e [i] = t [i]); return e}, de = ['início automático', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'end-end', 'bottom-end', 'bottom', 'bottom -start ',' left-end ',' left ',' left-start '], ae = de.slice (3), le = {FLIP:' flip ', HORÁRIO DE RELÓGIO:' no sentido horário ', COUNTERCLOCKWISE:' no sentido anti-horário ' }fe = function () {função t (o, i) {var n = isto, r = 2 <argumentos.length && void 0! == argumentos [2]? argumentos [2]: {}; ne (isto, t), this.scheduleUpdate = function () {retornar requestAnimationFrame (n.update)}, this.update = oe (this.update.bind (this)), this.options = se ({}, t.Defaults, r), este .state = {isDestroyed:! 1, isCreated:! 1, scrollParents: []}, this.reference = o && o.jquery? o [0]: o, isto.popper = i && i.jquery? i [0]: i, this.options.modifiers = {}, Object.keys (se ({}, t.Defaults.modifiers, r.modifiers)) forEach (function (e) {n.options.modifiers [e] = se ({} , t.Defaults.modifiers [e] || {}, r.modifiers? r.modifiers [e]: {})}), this.modifiers = Object.keys (this.options.modifiers) .map (função ( e) {return se ({nome: e}, n.options.modifiers [e])}). sort (função (e, t) {return e.order-t.order}), this.modifiers.forEach ( function (t) {t.enabled && e (t.onLoad) && t.onLoad (n.referência, n.popper, n.options, t, n.state)}), this.update (); var p = this.options.eventsEnabled; p && this.enableEventListeners (), this.state.eventsEnabled = p} return re (t, [{key: ' update ', valor: function () {retornar N.call (this)}}, {chave:' destroy ', valor: function () {retorno P.call (this)}}, {chave:' enableEventListeners ', valor : function () {return I.call (this)}}, {chave: 'disableEventListeners', valor: function () {retorno R.call (this)}}]), t} (); retorno fe.Utils = ('indefinido' == tipo de janela? global: janela) .PopperUtils, fe.placements = de, fe.Defaults = {colocação: 'inferior', eventosEnabled:! 0, removeOnDestroy:! 1, onCreate: function () {} , onUpdate: function () {}, modificadores: {shift: {ordem: 100, ativada:! 0, fn: function (e) {var = e.placement, o = t.split ('-') [0 ], i = t.split ('-') [1]; se (i) {var n = e.offsets, r = n.referência, p = n.popper, s = -1! == ['bottom ','topo'].indexOf (o), d = s 'left': 'top', a = s 'width': 'height', l = {início: pe ({}, d, r [d]), final: pe ({}, d, r [d] + r [a] -p [a])}; e.offsets.popper = se ({}, p, l [i])} retorna e}}, deslocamento: { order: 200, enabled:! 0, fn: G, offset: 0}, preventOverflow: {ordem: 300, ativada:! 0, fn: function (e, t) {var = t.boundariesElement || r (e .instance.popper); e.instance.reference === o && (o = r (o)); var i = y (e.instance.popper, e.instance.reference, t.padding, o); limites = i; var n = t.prioridade, p = e.offsets.popper, s = {primary: function (e) {var = p [e]; return p [e] <i [e] &&! t .escapeWithReference && (o = J (p [e], i [e])), pe ({}, e, o)}, secundário: função (e) {var o = 'direito' === e? 'restante ':' top ', n = p [o]; retorno p [e]> i [e] &&! t.escapeWithReference && (n = _ (p [o], i [e] - (' direito '=== e? p.width: p.height))), pe ({}, o, n)}}; retorna n.forEach (function (e) {var t = -1 === ['left ',' top ']. indexOf (e)?' secundário ':' primário '; p = se ({}, p, s [t] (e))}), e.offsets.popper = p, e }, priority: ['left', 'right', 'top', 'bottom'], preenchimento: 5, boundariesElement: 'scrollParent'}, keepTogether: {order: 400, enabled:! 0, fn: function (e ) {var t = e.offsets, o = t.popper, i = t.reference, n = e.placement.split ('-') [0], r = X, p = -1! == [' top ',' bottom ']. indexOf (n), s = p' right ':' bottom ', d = p' left ':' top ', a = p' width ':' height '; o [s] <r (i [d]) && (e.offsets.popper [d] = r (i [d]) - o [a]), o [d]> r (i [s]) && (e.offsets.popper [d] = r (i [s])), e}}, seta: {ordem: 500, ativada:! 0, fn: function (e, o) {var i; if (! F (e.instance.modifiers, 'arrow', 'keepTogether')) return e; var n = o.element; if ('string' == typeof n) {if (n = e.instance.popper.querySelector (n),! n) retorna e;} else if (! e.instance.popper.contains (n)) return console.warn ('AVISO: `arrow.element` deve ser filho de seu elemento popper!') , e = var.placement.split ('-') [0], p = e.offsets, s = p.popper, d = p.reference, a = -1! == ['left', 'right']. indexOf (r), l = a 'height': 'width', f = a 'Top': 'Left', m = f.toLowerCase (), h = a 'left': 'topo', g = a 'inferior': 'direito', u = L (n) [l]; d [g] -u <s [m] && (e.offsets.popper [m] - = s [m] - (d [g] -u)), d [m] + u> s [g] && (e.offsets.popper [m] + = d [m] + us [g]), e. offsets.popper = c (e.offsets.popper); var b = d [m] + d [l] / 2-u / 2, w = t (e.instance.popper), y = parseFloat (w [' margin '+ f], 10), E = parseFloat (w [' border '+ f +' Width '], 10), v = be.offsets.popper [m] -yE; retorno v = J (_ (s [ l] -u, v), 0), e.arrowElement = n, e.offsets.arrow = (i = {}, pe (i, m,Math.round (v)), pe (i, h, ''), i), e}, elemento: '[x-arrow]'}, flip: {ordem: 600, ativada:! 0, fn: function (e, t) {if (k (e.instance.modifiers, 'inner')) return e; if (e.flipped && e.placement === e.originalPlacement) retornar e; var o = y (e.instance. popper, e.instance.reference, t.padding, t.boundariesElement), i = e.placement.split ('-') [0], n = x (i), r = e.placement.split ('- ') [1] ||' ', p = []; troca (t.behavior) {caso le.FLIP: p = [i, n]; quebra; caso le.CLOCKWISE: p = q (i); case le.COUNTERCLOCKWISE: p = q (i,! 0); quebra; padrão: p = t.behavior;} return p.forEach (função (s, d) {if (i! == s || p. length === d + 1) return e; i = e.placement.split ('-') [0], n = x (i); var a = e.offsets.popper, l = e.offsets.reference , f = X, m = 'esquerda' === i && f (a.right)> f (l.left) || 'right' === i && f (a.left) <f (l.right) || ' topo '=== i && f (a.bottom)> f (l.topo) || 'inferior' === i && f (a.top) <f (l.bottom), h = f (a.left) <f (o.left), c = f (a.right)> f (o.right), g = f (a.top) <f (o.top), u = f (a.bottom)> f (o.bottom), b = 'esquerda' === i && h || ' right '=== i && c ||' top '=== i && g ||' bottom '=== i && u, w = -1! == [' top ',' bottom ']. indexOf (i), y =! ! t.flipVariations && (w && 'start' === r && h || w && 'end' === r && c ||! w && 'start' === r && g ||! w && 'end' === r && u); (m | | b || y) && (e.flipado =! 0, (m || b) && (i = p [d + 1]), y && (r = K (r)), e.placement = i + (r ? '-' + r: ''), e.offsets.popper = se ({}, e.offsets.popper, S (e.instance.popper, e.offsets.reference, e.placement)), e = C (e.instance.modifiers, e, 'flip'))}), e}, comportamento: 'flip', padding: 5,boundariesElement: 'viewport'}, inner: {order: 700, enabled:! 1, fn: function (e) {var. = e.placement, o = t.split ('-') [0], i = e .offsets, n = i.popper, r = i.reference, p = -1! == ['left', 'right']. indexOf (o), s = -1 === ['top', ' esquerda ']. indexOf (o); retorna n [p?' esquerda ':' topo '] = r [o] - (s? n [p?' largura ':' altura ']: 0), e.placement = x (t), e.offsets.popper = c (n), e}}, esconder: {ordem: 800, habilitado:! 0, fn: function (e) {if (! F (e.instance.modifiers , 'hide', 'preventOverflow')) return e; var t = e.offsets.reference, o = T (e.instance.modifiers, função (e) {return'preventOverflow '=== e.name}). boundaries; if (t.bottom <o.top || t.left> o.right || t.top> o.bottom || t.right <o.left) {if (! 0 === e.hide ) return e; e.hide =! 0, e.attributes ['x-fora-dos-limites'] = ''} else {if (! 1 === e.hide) return e; e.hide =! 1, e.attributes ['x-out-of-boundaries '] =! 1} return e}}, computeStyle: {ordem: 850, ativada:! 0, fn: function (e, t) {var o = tx, i = ty, n = e.offsets.popper, p = T (e.instance.modifiers, função (e) {return'applyStyle '=== e.name}). gpuAcceleration; void 0! == p && console.warn (' AVISO: `gpuAcceleration `opção movida para o modificador` computeStyle` e não será suportada em futuras versões do Popper.js! '); var s, d, a = void 0 === p? t.gpuAcceleration: p, l = r (e. exemplo.popper), f = g (l), m = {posição: n.posição}, h = {esquerda: X (n.left), topo: X (n.top), inferior: X (n.bottom ), right: X (n.right)}, c = 'bottom' === o? 'top': 'bottom', u = 'right' === i? 'left': 'right', b = W ('transformar'); if (d = 'bottom' == c? -f.height + h.bottom: h.top, s = 'right' == u? - f.width + h.right: h .left, a && b) m [b] = 'traduzir3d (' + s + 'px,' + d + 'px, 0)',m [c] = 0, m [u] = 0, m.willChange = 'transformar'; mais {var w = 'inferior' == c? -1: 1, y = 'direito' == u? -1 : 1; m [c] = d * w, m [u] = s * y, m.willChange = c + ',' + u} var E = {"x-placement": e.placement}; return e. atributos = se ({}, E, e.atributos), e.styles = se ({}, m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {ordem: 900, ativado:! 0, fn: function (e) {retorno Y (e.instance.popper, e .styles), j (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('x-posicionamento', p), Y (t, {posição: 'absoluto'}), o}, gpuAcceleration: void 0}}}, fe});willChange = 'transform'; else {var w = 'bottom' == c? -1: 1, y = 'right' == u? -1: 1; m [c] = d * w, m [u] = s * y, m.willChange = c + ',' + u} var E = {"x-placement": e.placement}; return e.attributes = se ({}, E, e.atributos), e. styles = se ({}, m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes) , e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p), Y ( t, {position: 'absolute'}), o}, gpuAcceleration: void 0}}}, fe});willChange = 'transform'; else {var w = 'bottom' == c? -1: 1, y = 'right' == u? -1: 1; m [c] = d * w, m [u] = s * y, m.willChange = c + ',' + u} var E = {"x-placement": e.placement}; return e.attributes = se ({}, E, e.atributos), e. styles = se ({}, m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes) , e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p), Y ( t, {position: 'absolute'}), o}, gpuAcceleration: void 0}}}, fe});else {var w = 'inferior' == c? -1: 1, y = 'direito' == u? -1: 1; m [c] = d * w, m [u] = s * y, m .willChange = c + ',' + u} var E = {"x-placement": e.placement}; return e.attributes = se ({}, E, e.attributes), e.styles = se ({} , m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'direito'}, applyStyle : {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('x-posicionamento', p), Y (t, {posição: ' absolute '}), o}, gpuAcceleration: void 0}}}, fe});else {var w = 'inferior' == c? -1: 1, y = 'direito' == u? -1: 1; m [c] = d * w, m [u] = s * y, m .willChange = c + ',' + u} var E = {"x-placement": e.placement}; return e.attributes = se ({}, E, e.attributes), e.styles = se ({} , m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'direito'}, applyStyle : {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); return t.setAttribute ('x-posicionamento', p), Y (t, {posição: ' absolute '}), o}, gpuAcceleration: void 0}}}, fe});m [u] = s * y, m.willChange = c + ',' + u} var E = {"x-placement": e.placement}; return e.attributes = se ({}, E, e.atributos ), e.styles = se ({}, m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom ', y:' right '}, applyStyle: {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O ( n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p ), Y (t, {posição: 'absoluta'}), o}, gpuAcceleration: void 0}}}, fe});m [u] = s * y, m.willChange = c + ',' + u} var E = {"x-placement": e.placement}; return e.attributes = se ({}, E, e.atributos ), e.styles = se ({}, m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom ', y:' right '}, applyStyle: {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes), e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O ( n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p ), Y (t, {posição: 'absoluta'}), o}, gpuAcceleration: void 0}}}, fe});styles = se ({}, m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes) , e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p), Y ( t, {position: 'absolute'}), o}, gpuAcceleration: void 0}}}, fe});styles = se ({}, m, e.styles), e.arrowStyles = se ({}, e.offsets.arrow, e.arrowStyles), e}, gpuAcceleration:! 0, x: 'bottom', y: 'right'}, applyStyle: {ordem: 900, habilitado:! 0, fn: function (e) {retorno Y (e.instance.popper, e.styles), j (e.instance.popper, e.attributes) , e.arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p), Y ( t, {position: 'absolute'}), o}, gpuAcceleration: void 0}}}, fe});arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p), Y (t, { position: 'absolute'}), o}, gpuAcceleration: void 0}}}, fe});arrowElement && Object.keys (e.arrowStyles) .length && Y (e.arrowElement, e.arrowStyles), e}, onLoad: function (e, t, o, i, n) {var r = O (n, t, e), p = v (o.placement, r, t, e, o.modifiers.flip.boundariesElement, o.modifiers.flip.padding); retorne t.setAttribute ('x-placement', p), Y (t, { position: 'absolute'}), o}, gpuAcceleration: void 0}}}, fe});
// # sourceMappingURL = popper.min.js.map